@volatile
private type JsonContract {
    /// identifier of the contract
    name: String;
    /// commercial name of the contract, the one users usually know
    commercial_name: String?;
    /// code (ISO 3166) of the country
    country_code: String?;
    /// cities that are concerned by this contract
    cities: Array<String>?;
}

@volatile
private type JsonStation {
    /// number of the station. This is NOT an id, thus it is unique only inside a contract.
    number: int;
    /// name of the contract of the station
    contract_name: String;
    /// name of the station
    name: String;
    /// address of the station. As it is raw data, sometimes it will be more of a comment than an address.
    address: String;
    /// position of the station in WGS84 format
    position: geo;
    /// indicates whether this station has a payment terminal
    banking: bool;
    /// indicates whether this is a bonus station
    bonus: bool;
    /// total number of bike stands in the station
    bike_stands: int;
    /// currently available number of bike stands in the station
    available_bike_stands: int;
    /// currently available number of bikes in the station
    available_bikes: int;
    /// indicates whether this station is `"CLOSED"` or `"OPEN"`
    status: StationStatus;
    /// timestamp indicating the last update time in milliseconds
    last_update: int?;
}

/// Tries to load the API key from env var `"JCDECAUX_API_KEY"`
///
/// If the key is not defined, it will throw an error.
fn api_key(): String {
    var key = System::getEnv("JCDECAUX_API_KEY");
    if (key == null) {
        throw "no JCDECAUX_API_KEY found in environment";
    }
    return key;
}

/// Imports contracts from the JCDecaux API.
///
/// Every non-existent contract will be initialized and set in `model::contracts_by_name`
fn import_contracts() {
    // Read the api key from env, or early exits with an exception
    var api_key = api_key();

    // Will return an array of objects with all the contracts
    //
    // GreyCat's `Http` type is generic over the expected response type
    // if the deserialization fails this call will throw an exception
    var contracts = Http<Array<JsonContract>> {}.get(
        "https://api.jcdecaux.com/vls/v1/contracts?apiKey=${api_key}",
        Map<String, String> { "accept": "application/json" }
    );

    // We then iterate the items, the first argument `_` is the index in the array
    // we do not need it, so we ignore it with this notation
    for (_, item in contracts) {
        // The name works as the identifier of the contract as explained in the JCDecaux API documentation
        // We check if the contract does not exists in the graph
        if (contracts_by_name.get(item.name) == null) {
            // Create the contract typed object using the data from the response
            var contract = Contract {
                name: item.name,
                cities: item.cities,
                commercial_name: item.commercial_name,
                country_code: item.country_code,
                // we initialize an index of stations
                stations: nodeIndex<int, node<Station>> {},
            };

            // We create the contract node
            // This will make the contract persistent in the graph
            // For more information about nodes see: https://doc.greycat.io/concepts/nodes/index.html
            var n_contract = node<Contract> { contract };

            // We add the contract to the index declared in `src/model.gcl`
            contracts_by_name.set(item.name, n_contract);
        }
    }
}

/// Imports stations from the JCDecaux API.
///
/// Stores the stations in their respective `Contract` if it exists, otheriwe ignore the station.
fn import_stations() {
    // Read the api key from env, or early exits with an exception
    var api_key = api_key();

    // Will return an array of objects with all the stations
    //
    // GreyCat's `Http` type is generic over the expected response type
    // if the deserialization fails this call will throw an exception
    var data = Http<Array<JsonStation>> {}.get(
        "https://api.jcdecaux.com/vls/v1/stations?apiKey=${api_key}",
        Map<String, String> { "accept": "application/json" }
    );

    for (_, item in data) {
        if (item.last_update == null) {
            continue;
        }

        // Get the station number, which is unique by contract
        var number = item.number;

        // Get the contract name to get our locally stored contract indexed by contract name
        var contract = contracts_by_name.get(item.contract_name);
        if (contract == null) {
            // If the contract does not exist we skip the station
            // This could happen if since the last time we fetched the contracts a new contract with stations has been added
            // We could refetch the contracts but for the sake of simplicity we will just skip the station
            continue;
        }

        var n_station = contract->stations.get(number);
        if (n_station == null) {
            var quantizer = MultiQuantizer {
                quantizers: Array<Quantizer> {
                    LinearQuantizer<int> { min: 0, max: 6, bins: 7 },
                    LinearQuantizer<int> { min: 0, max: 23, bins: 24 }
                }
            };
            var stationProfile = StationProfile {
                hourlyProfile: GaussianProfile {
                    quantizer: quantizer,
                    precision: FloatPrecision::p10
                },
                hourlyQuantizer: clone(quantizer),
            };

            var station = Station {
                number: number,
                position: item.position,
                detail: node<StationDetail> {
                    StationDetail {
                        name: item.name,
                        address: item.address,
                        banking: item.banking,
                        bonus: item.bonus,
                    }
                },
                records: nodeTime<StationRecord> {},
                contract: contract,
                profile: node<StationProfile> { stationProfile }
            };

            n_station = node<Station> { station };
            stations_by_geo.set(item.position, n_station);

            // We add the station to the contract
            contract->stations.set(number, n_station);
        }

        // Convert the update time in millisecond into GreyCat's `time` representation
        var timestamp = time::new(item.last_update, DurationUnit::milliseconds);

        // We check if we alraedy have the data for this timestamp.
        if (n_station->records.getAt(timestamp) == null) {
            var record = StationRecord {
                status: item.status,
                available_bikes: item.available_bikes,
                available_bike_stands: item.available_bike_stands,
                bike_stands: item.bike_stands,
            };
            n_station->records.setAt(timestamp, record);
            n_station->profile->updateProfile(timestamp, record);
        }
    }
}

/// The following code is to simply allow to load and dump data to launch the app with some data without requiring an api key
fn export_records() {
    for (_, contract in contracts_by_name) {
        for (number, station in contract->stations) {
            var csv = CsvWriter<InternalRecordsDTO> {
                path: "tmp/${contract->name}_${number}.csv",
                format: CsvFormat {}
            };

            for (key, data in station->records) {
                csv.write(
                    InternalRecordsDTO {
                        time: key,
                        status: data.status,
                        availableBikes: data.available_bikes,
                        availableBikeStands: data.available_bike_stands,
                        bikeStands: data.bike_stands
                    }
                );
            }
        }
    }
}

@volatile
type InternalContractDTO {
    name: String;
    cities: Array<String>?;
    commercial_name: String?;
    country_code: String?;
    stations: Array<InternalStationDTO>;
}

@volatile
type InternalStationDTO {
    number: int;
    position: geo;
    detail: StationDetail;
}

fn export_data() {
    var fw = JsonWriter { path: "tmp/data.ndjson" };

    for (_, contractRef in contracts_by_name) {
        var contract = contractRef.resolve();
        var contractObj = InternalContractDTO {
            name: contract.name,
            cities: contract.cities,
            commercial_name: contract.commercial_name,
            country_code: contract.country_code,
            stations: Array<InternalStationDTO> {}
        };
        for (_, value in contract.stations) {
            var station = value.resolve();
            var stationObj = InternalStationDTO {
                number: station.number,
                position: station.position,
                detail: station.detail.resolve(),
            };
            contractObj.stations.add(stationObj);
        }
        fw.writeln(contractObj);
    }
}

fn import_data() {
    var fr = JsonReader<InternalContractDTO> { path: "tmp/data.ndjson" };

    while (fr.can_read()) {
        var contractObj = fr.read();

        var contractRef = contracts_by_name.get(contractObj.name);

        if (contractRef == null) {
            var contract = Contract {
                name: contractObj.name,
                cities: contractObj.cities,
                commercial_name: contractObj.commercial_name,
                country_code: contractObj.country_code,
                stations: nodeIndex<int, node<Station>> {},
            };
            contractRef = node<Contract> { contract };
            contracts_by_name.set(contract.name, contractRef);
        }

        for (_, stationObj in contractObj.stations) {
            var number = stationObj.number;

            //If the station already exists we skip it
            if (contractRef->stations.get(number) != null) {
                continue;
            }

            var stationDetail = StationDetail {
                name: stationObj.detail.name,
                address: stationObj.detail.address,
                banking: stationObj.detail.banking,
                bonus: stationObj.detail.bonus,
            };

            var quantizer = MultiQuantizer<int> {
                quantizers: Array<Quantizer<int>> {
                    LinearQuantizer<int> { min: 0, max: 6, bins: 7 },
                    LinearQuantizer<int> { min: 0, max: 23, bins: 24 }
                }
            };
            var stationProfile = StationProfile {
                hourlyProfile: GaussianProfile<Array<int>> {
                    quantizer: quantizer,
                    precision: FloatPrecision::p10
                },
                hourlyQuantizer: clone(quantizer)
            };

            var station = Station {
                number: stationObj.number,
                position: stationObj.position,
                detail: node<StationDetail> { stationDetail },
                records: nodeTime<StationRecord> {},
                contract: contractRef,
                profile: node<StationProfile> { stationProfile }
            };

            var stationRef = node<Station> { station };
            contractRef->stations.set(station.number, stationRef);
            stations_by_geo.set(station.position, stationRef);
        }
    }
}

// Used for importing and exporting for internal use only

@volatile
type InternalRecordsDTO {
    time: time;
    status: StationStatus;
    availableBikes: int;
    availableBikeStands: int;
    bikeStands: int;
}

fn import_records() {
    var files = File::ls("tmp", ".csv", true);

    for (key, file in files) {
        import_record(file);
    }
}

private fn import_record(file: File) {
    var fileName = file.name();
    var split = fileName.indexOf('_');
    var stationNumber = fileName.slice(split + 1, fileName.size() - 4);
    var contractName = fileName.slice(0, split);
    var contract = contracts_by_name.get(contractName);
    var stationRef = contract?->stations.get(parseNumber(stationNumber) as int);
    if (stationRef == null) {
        return;
    }

    var csv = CsvReader<InternalRecordsDTO> {
        path: file.path,
        format: CsvFormat {}
    };

    while (csv.can_read()) {
        var r = csv.read();

        var record = StationRecord {
            status: r.status,
            available_bikes: r.availableBikes,
            available_bike_stands: r.availableBikeStands,
            bike_stands: r.bikeStands,
        };

        stationRef->records.setAt(r.time, record);
        stationRef->profile->updateProfile(r.time, record);
    }
}
